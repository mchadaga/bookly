{% extends "web/base.html" %} {% load i18n %} {% load static %} {% block body %}
{% comment %} {{hooks}} {% endcomment %}

<div class="flex flex-col items-center justify-center w-full min-h-screen">
  <div id="text-content" class="text-content" style="display: none; width: 75%">
    <h1 id="hook-text"></h1>
      <div id="paragraphs"></div>
      <div class="tracker-spacer"></div>
      <div class="spacer"></div>
    </div>
  </div>

  <input
  placeholder = "Press [Space] to read further, [Enter] for next story, or input in any questions you have for HookBook AI here."
  id="entered"
  style="
    font-size: 16px;
    padding-left: 15px;
    position: fixed;
    bottom: 1vw;
    left: 12.5vw;
    width: 75vw;
    border-radius:2.5rem; 
    height: 50px;
    display: none;

    "
  />

  <div
  id = "entered-placeholder"
  style="
  font-size: 16px;
  padding-left: 15px;
  position: fixed;
  bottom: 1vw;
    left: 50%;
    transform: translateX(-50%);
  border-radius:2.5rem; 
  height: 50px;
  display:block; 
  font-size: 1.5rem;

  "
    >

    Press [Space] to read more

  </div>


  <div
  
  id = "endstorymsg"
  style="
  font-size: 16px;
  padding-left: 15px;
  position: fixed;
  bottom: 1vw;
    left: 50%;
    transform: translateX(-50%);
  border-radius:2.5rem; 
  display:none; 
  font-size: 1.5rem;
  background:rgb(255,255,255);
  border-radius: 1rem;
  padding: 1rem;
  color: rgb(0,0,0);
  white-space: nowrap; 
  
  "


    >
  Congrats! You've finised this story ðŸŽ‰! Press [Enter] to read your next story
  </div>


  <div>
    {% comment %}
    <div
      id="clicked-textcontents"
      style="font-size: 0.8em; margin-top: 20px"
    ></div>
    {% endcomment %}



    <style>
      .text-content h1 {
        font-size: 2.5rem;
        margin-bottom: 1rem;
      }
      .sentence {
        font-size: 1.5rem;
        line-height: 1.6;
        margin-bottom: 1rem;
      }
      .trackerspacer {
        height: 0rem;
      }

      .spacer {
        height: 50vh;
      }
      #chat-container {
        position: fixed;
        top: 60px;
        right: 20px;
        width: 300px;
        height: calc(100vh - 120px);
        overflow-y: auto;
        background-color: rgba(255, 255, 255, 0.9);
        border: 1px solid #ccc;
        border-radius: 5px;
        padding: 10px;
      }
      .chat-message {
        margin: 1rem 0;
        padding: 0.5rem;
        border-radius: 5px;
        color: #000;
      }
      .user-message {
        background-color: #e6f2ff;
      }
      .ai-message {
        background-color: #f0f0f0;
      }




    </style>
    <script src="
    https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js
    "></script>
    <script>
      let currentSentenceIndex = -1;
      let currentTextContentId = null;
      let enteredStory = false;
      let storyFinished = false;

      let question = null;
      let answer = null;
      
      let chatInputFocused = false;
      let chatHistory = [];
      let audioElement = new Audio();  // Add this line

      let enteredPlaceholder = document.getElementById("entered-placeholder");
      let entered = document.getElementById("entered");
      let endStoryMsg = document.getElementById("endstorymsg"); 
      let spacer = document.querySelector(".spacer");

      let trackerSpacer = document.querySelector(".tracker-spacer");    

      let modalOpen = false;  // Add this variable to track if the modal is open


      function triggerConfetti() {
        confetti({
        particleCount: 100,
        spread: 70,
        origin: { y: 0.6 }
        });
        }
        



      function fetchRandomTextContent() {
        const url = new URL(
          '{% url "app:get_random_textcontent" %}',
          window.location.origin
        );
        console.log(enteredStory);
        url.searchParams.append("entered", enteredStory);

        fetch(url)
          .then((response) => response.json())
          .then((data) => {
            currentTextContentId = data.id;
            document.getElementById("hook-text").innerHTML = data.hook.split(' ').map((word, index) => 
              `<span class="word" id="word-${index}">${word}</span>`
            ).join(' ');
            wordTimings = data.hook_timestamps;
            const paragraphsContainer = document.getElementById("paragraphs");
            paragraphsContainer.innerHTML = "";
            data.paragraphs.forEach((paragraph) => {
              paragraph.sentences.forEach((sentence) => {
                const p = document.createElement("p");
                p.className = "sentence";
                p.style.display = "none";
                p.textContent = sentence.sentence_text;
                paragraphsContainer.appendChild(p);
              });
            });
            currentSentenceIndex = -1;
            document.getElementById("text-content").style.display = "block";

            if (data.hook_audio) {
              playHookAudio(data.hook_audio);
            } else {
              speakHook(data.hook);
            }

            prepareHookForHighlighting();

            // Reset enteredStory for the next fetch
            enteredStory = false;
          })
          .catch((error) => console.error("Error:", error));
      }

      function prepareHookForHighlighting() {
        const hookElement = document.getElementById("hook-text");
        const words = hookElement.textContent.split(' ');
        hookElement.innerHTML = words.map((word, index) => `<span class="word" id="word-${index}">${word}</span>`).join(' ');
    }
    
    function highlightWords() {
        if (!wordTimings){
            console.log("NO WORD TIMINGS")
            return;
        } 

        console.log(wordTimings)
    
        const words = document.querySelectorAll('#hook-text .word');
        const currentTime = audioElement.currentTime;
        let wordIndex = 1;
    
        for (let i = 1; i < wordTimings.characters.length; i++) {
            if (currentTime >= wordTimings.character_start_times_seconds[i]) {
                if (wordTimings.characters[i] === ' ') {
                    wordIndex++;
                }
            } else {
                break;
            }
        }
    
        words.forEach((word, index) => {
            if (index < wordIndex) {
                word.classList.add('highlighted');
            } else {
                word.classList.remove('highlighted');
            }
        });
    }
    

      function playHookAudio(audioUrl) {
        audioElement.src = audioUrl;
        audioElement.play().catch(error => console.error("Error playing audio:", error));
        //document.getElementById("play-audio-button").style.display = "none";
        
        // Add these lines to start highlighting words
        audioElement.addEventListener('timeupdate', highlightWords);
        highlightWords(); // Call once immediately to highlight the first word
      }

      function speakHook(text) {
        setTimeout(() => {
          const utterance = new SpeechSynthesisUtterance(text);
          window.speechSynthesis.speak(utterance);
        }, 100);
      }

      function trackTextContentClick() {
        if (currentTextContentId) {
          fetch('{% url "app:track_textcontent_click" %}', {
            method: "POST",
            headers: {
              "Content-Type": "application/x-www-form-urlencoded",
              "X-CSRFToken": "{{ csrf_token }}",
            },
            body: `textcontent_id=${currentTextContentId}`,
          })
            .then((response) => response.json())
            .then((data) => {
              if (data.status === "success") {
                updateClickedTextContents();
              }
            })
            .catch((error) => console.error("Error:", error));
        }
      }

      function updateClickedTextContents() {
        fetch('{% url "app:get_user_textcontents" %}')
          .then((response) => response.json())
          .then((data) => {
            const container = document.getElementById("clicked-textcontents");
            container.innerHTML =
              "Clicked TextContents: " + data.map((tc) => tc.name).join(", ");
          })
          .catch((error) => console.error("Error:", error));
      }

      function askAI(userMessage) {
        const formData = new FormData();
        formData.append("textcontent_id", currentTextContentId);
        formData.append("current_sentence_index", currentSentenceIndex);
        formData.append("user_question", userMessage);
        console.log("hi");

        return fetch('{% url "app:ask_ai_about_story" %}', {
          method: "POST",
          body: formData,
        })
          .then((response) => {
            if (!response.ok) {
              throw new Error("Network response was not ok");
            }
            return response.json();
          })
          .then((data) => data.ai_response)
          .catch((error) => {
            console.error("Error:", error);
            return "Sorry, I couldn't process your question. Please try again.";
          });
      }

      document.addEventListener("keydown", function (event) {
        const chatInput = document.getElementById("entered");

        if (event.key === "`") {
          event.preventDefault();
          chatInput.focus();
        }

        if (document.activeElement !== chatInput && !modalOpen) {  // Add !modalOpen check
          if (event.key === "Enter") {
            endStoryMsg.style.display = 'none';
            enteredPlaceholder.style.display = 'block';
            entered.style.display = 'none';

            if (storyFinished) {
              // User finished the story and wants to move to the next one
              storyFinished = false;
              enteredStory = true;
              fetchRandomTextContent();
            } else {
              // User is skipping the current story
              window.speechSynthesis.cancel();
              enteredStory = false;
              fetchRandomTextContent();
            }
          } else if (event.code === "Space") {
            enteredPlaceholder.style.display = 'none';
            entered.placeholder = "Press [Space] to read further, [Enter] for next story, or input in any questions you have for HookBook AI here."
            entered.style.display = 'block';

            event.preventDefault();
            const sentences = document.querySelectorAll(".sentence");
            if (currentSentenceIndex < sentences.length - 1) {


              currentSentenceIndex++;
              sentences[currentSentenceIndex].style.display = "block";
            



             trackerSpacer.scrollIntoView({
                    behavior: "smooth", // Optional, smooth scrolling
                    block: "center",       // Align the bottom of the element with the bottom of the viewport
                    inline: "nearest"   // Keep the nearest horizontal alignment, typically you won't need to modify this
                  });



              if (currentSentenceIndex === 0) {
                // User entered the story
             

                enteredStory = true;
                trackTextContentClick();
              }
            } else if (currentSentenceIndex === sentences.length - 1) {
                entered.placeholder = "Congrats on finishing this story! ðŸŽ‰ Press [Enter] to read your next story"
                triggerConfetti();
                //question_handle();

              // Fetch a question from the getquestion endpoint
              fetch(`{% url 'app:get_question' %}?text_content_id=${currentTextContentId}`)
                .then(response => response.json())
                .then(data => {
                  if (data.question) {
                    console.log(data.question);
                    question = data.question;
                    console.log(data.answer);
                    answer = data.answer;
                    // Create a bubble with the question
                    const questionBubble = document.createElement('button');
                    questionBubble.className = 'question-bubble';
                    questionBubble.textContent = data.question;

                    // Add click event listener to open the modal
                    questionBubble.addEventListener('click', () => openQuestionModal(data.question, data.answer));

                    // Insert the question bubble after the last sentence
                    const lastSentence = document.querySelector('.sentence:last-child');
                    if (lastSentence) {
                      lastSentence.insertAdjacentElement('afterend', questionBubble);
                    }

                    // Scroll to the question bubble
                    questionBubble.scrollIntoView({
                      behavior: 'smooth',
                      block: 'center',
                      inline: 'nearest'
                    });
                  }
                })
                .catch(error => console.error('Error fetching question:', error));
                

              // User has reached the last sentence
              storyFinished = true;
              // Optionally, you can display a message here to prompt the user to press Enter
              console.log(
                "Story finished. Press Enter to continue to the next story."
              );
            }
          }
        } else if (
          document.activeElement === chatInput &&
          event.key === "Enter" &&
          chatInput.value.trim() !== ""
        ) {



          event.preventDefault();
          const userMessage = chatInput.value.trim();
          chatInput.value = "";

          // Use the askAI function to get the AI response
          askAI(userMessage).then((aiResponse) => {
            updateChatDisplay(userMessage, aiResponse);

            // Auto-unfocus the input after sending a message
            chatInput.blur();
          });
        }
      });

      function updateChatDisplay(userMessage, aiResponse) {
        const paragraphsContainer = document.getElementById("paragraphs");
        const visibleSentences = Array.from(
          paragraphsContainer.children
        ).filter((el) => el.style.display !== "none");
        const lastVisibleSentence =
          visibleSentences[visibleSentences.length - 1];

        if (lastVisibleSentence) {
          const chatContainer = document.createElement("div");
          chatContainer.className = "chat-container";

          const userMessageElement = document.createElement("div");
          userMessageElement.className = "chat-message user-message";
          userMessageElement.textContent = userMessage;
          chatContainer.appendChild(userMessageElement);

          const aiMessageElement = document.createElement("div");
          aiMessageElement.className = "chat-message ai-message";
          aiMessageElement.textContent = aiResponse;
          chatContainer.appendChild(aiMessageElement);

          lastVisibleSentence.insertAdjacentElement("afterend", chatContainer);
        }
      }

      document.getElementById("entered").addEventListener("blur", function () {
        chatInputFocused = false;
      });

      fetchRandomTextContent();
      updateClickedTextContents();
    </script>

  </div>
</div>
<style>
.word {
    transition: background-color 0.3s ease;
    display: none
}
.word.highlighted {
    {% comment %} background-color: yellow; {% endcomment %}
    color: white;
    font-weight: bold;
    display: inline-block;
}
</style>

<script>
// Add these new functions and HTML elements for the modal
function openQuestionModal(question, answer) {
  document.getElementById('questionText').textContent = question;
  document.getElementById('questionModal').style.display = 'block';
  document.getElementById('userAnswer').value = '';
  document.getElementById('aiResponse').textContent = '';
  modalOpen = true;  // Set modalOpen to true when opening the modal
}

function closeQuestionModal() {
  document.getElementById('questionModal').style.display = 'none';
  modalOpen = false;  // Set modalOpen to false when closing the modal
}

function submitAnswer() {
  const userInput = document.getElementById('userAnswer').value;
  const question = document.getElementById('questionText').textContent;

  // Call the question_handle endpoint
  fetch('{% url "app:question_handle" %}', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/x-www-form-urlencoded',
      'X-CSRFToken': '{{ csrf_token }}'
    },
    body: `question=${encodeURIComponent(question)}&answer=${encodeURIComponent(answer)}&user_input=${encodeURIComponent(userInput)}`
  })
  .then(response => response.json())
  .then(data => {
    if (data.response['STATUS'] == "complete" || data.response['STATUS'] == "complete and detailed"){
        document.getElementById('aiResponse').textContent = "Complete. Great job!"
    }
    else{
        document.getElementById('aiResponse').textContent = data.response['STATUS']+". "+data.response['NEXT QUESTION'];
    }
    if (data.conversation_ended) {
      //closeQuestionModal();
      triggerConfetti();
    }
  })
  .catch(error => console.error('Error:', error));
}
</script>

<div id="questionModal" class="modal" style="display: none; color: black;">
  <div class="modal-content">
    <span class="close" onclick="closeQuestionModal()">&times;</span>
    <h2>Question</h2>
    <p id="questionText" style="color: black;"></p>
    <textarea id="userAnswer" rows="4" cols="50"></textarea>
    <button onclick="submitAnswer()">Submit</button>
    <div id="aiResponse"></div>
  </div>
</div>

<style>
  .modal {
    display: none;
    position: fixed;
    z-index: 1;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0,0,0,0.4);
  }

  .modal-content {
    background-color: #fefefe;
    margin: 15% auto;
    padding: 20px;
    border: 1px solid #888;
    width: 80%;
    max-width: 600px;
  }

  .close {
    color: #aaa;
    float: right;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
  }

  .close:hover,
  .close:focus {
    color: black;
    text-decoration: none;
    cursor: pointer;
  }

  .question-bubble {
    background-color: #f0f0f0;
    border: none;
    padding: 10px 20px;
    margin: 10px 0;
    border-radius: 20px;
    cursor: pointer;
    font-size: 16px;
  }

  .question-bubble:hover {
    background-color: #e0e0e0;
  }
</style>

{% endblock %}